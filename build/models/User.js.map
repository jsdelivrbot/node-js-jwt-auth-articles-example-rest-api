{"version":3,"sources":["../../src/models/User.js"],"names":["UserSchema","mongoose","Schema","first","type","String","last","phone","lowercase","trim","index","unique","sparse","validate","validator","arguments","message","email","password","select","timestamps","pre","next","isModified","isNew","err","salt","hash","bcrypt","genSalt","methods","comparePassword","pw","pass","bcrypt_p","compare","virtual","set","name","split","get","getJWT","expiration_time","parseInt","CONFIG","jwt_expiration","jwt","sign","user_id","_id","jwt_encryption","expiresIn","toWeb","json","toJSON","id","model"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AACA;;;;;;;;AAGA,IAAIA,aAAaC,mBAASC,MAAT,CAAgB;AAC7BC,WAAO,EAACC,MAAMC,MAAP,EADsB;AAE7BC,UAAM,EAACF,MAAMC,MAAP,EAFuB;AAG7BE,WAAO;AACHH,cAAMC,MADH,EACWG,WAAW,IADtB,EAC4BC,MAAM,IADlC,EACwCC,OAAO,IAD/C,EACqDC,QAAQ,IAD7D,EACmEC,QAAQ,IAD3E,EACgF;AACnFC,kBAAU,CAAC,iCAAS;AAChBC,uBAAW,WADK;AAEhBC,uBAAW,CAAC,CAAD,EAAI,EAAJ,CAFK;AAGhBC,qBAAS;AAHO,SAAT,CAAD;AAFP,KAHsB;AAW7BC,WAAO;AACHb,cAAMC,MADH,EACWG,WAAW,IADtB,EAC4BC,MAAM,IADlC,EACwCC,OAAO,IAD/C,EACqDC,QAAQ,IAD7D,EACmEC,QAAQ,IAD3E;AAEHC,kBAAU,CAAC,iCAAS;AAChBC,uBAAW,SADK;AAEhBE,qBAAS;AAFO,SAAT,CAAD;AAFP,KAXsB;AAkB7B;AACAE,cAAU,EAACd,MAAMC,MAAP,EAAec,QAAQ,KAAvB;;AAnBmB,CAAhB,EAqBd,EAACC,YAAY,IAAb,EArBc,CAAjB;;AAuBApB,WAAWqB,GAAX,CAAe,MAAf;AAAA,uEAAuB,iBAAeC,IAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,8BAEhB,KAAKC,UAAL,CAAgB,UAAhB,KAA+B,KAAKC,KAFpB;AAAA;AAAA;AAAA;;AAIXC,2BAJW,WAINC,IAJM,WAIAC,IAJA;AAAA;AAAA,+BAKK,cAAGC,iBAAOC,OAAP,CAAe,EAAf,CAAH,CALL;;AAAA;AAAA;AAAA;AAKdJ,2BALc;AAKTC,4BALS;;AAMf,4BAAGD,GAAH,EAAQ,sBAAWA,IAAIT,OAAf,EAAwB,IAAxB;;AANO;AAAA,+BAQK,cAAGY,iBAAOD,IAAP,CAAY,KAAKT,QAAjB,EAA2BQ,IAA3B,CAAH,CARL;;AAAA;AAAA;AAAA;AAQdD,2BARc;AAQTE,4BARS;;AASf,4BAAGF,GAAH,EAAQ,sBAAWA,IAAIT,OAAf,EAAwB,IAAxB;;AAER,6BAAKE,QAAL,GAAgBS,IAAhB;;AAXe;AAAA;;AAAA;AAAA,yDAcRL,MAdQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAvB;;AAAA;AAAA;AAAA;AAAA;;AAkBAtB,WAAW8B,OAAX,CAAmBC,eAAnB;AAAA,wEAAqC,kBAAeC,EAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAC7BP,2BAD6B,WACxBQ,IADwB;;AAEjC,4BAAI,CAAC,KAAKf,QAAV,EAAoB,sBAAW,kBAAX;;AAFa;AAAA,+BAIb,cAAGgB,wBAASC,OAAT,CAAiBH,EAAjB,EAAqB,KAAKd,QAA1B,CAAH,CAJa;;AAAA;AAAA;AAAA;AAIhCO,2BAJgC;AAI3BQ,4BAJ2B;;AAKjC,4BAAIR,GAAJ,EAAS,sBAAWA,GAAX;;AAET,4BAAI,CAACQ,IAAL,EAAW,sBAAW,kBAAX;;AAPsB,0DAS1B,IAT0B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAArC;;AAAA;AAAA;AAAA;AAAA;;AAaAjC,WAAWoC,OAAX,CAAmB,WAAnB,EAAgCC,GAAhC,CAAoC,UAAUC,IAAV,EAAgB;AAChD,QAAIC,QAAQD,KAAKC,KAAL,CAAW,GAAX,CAAZ;AACA,SAAKpC,KAAL,GAAaoC,MAAM,CAAN,CAAb;AACA,SAAKjC,IAAL,GAAYiC,MAAM,CAAN,CAAZ;AACH,CAJD;;AAMAvC,WAAWoC,OAAX,CAAmB,WAAnB,EAAgCI,GAAhC,CAAoC,YAAY;AAAE;AAC9C,QAAG,CAAC,KAAKrC,KAAT,EAAgB,OAAO,IAAP;AAChB,QAAG,CAAC,KAAKG,IAAT,EAAe,OAAO,KAAKH,KAAZ;;AAEf,WAAO,KAAKA,KAAL,GAAa,GAAb,GAAmB,KAAKG,IAA/B;AACH,CALD;;AAOAN,WAAW8B,OAAX,CAAmBW,MAAnB,GAA4B,YAAU;AAClC,QAAIC,kBAAkBC,SAASC,iBAAOC,cAAhB,CAAtB;AACA,WAAO,YAAUC,uBAAIC,IAAJ,CAAS,EAACC,SAAQ,KAAKC,GAAd,EAAT,EAA6BL,iBAAOM,cAApC,EAAoD,EAACC,WAAWT,eAAZ,EAApD,CAAjB;AACH,CAHD;AAIA1C,WAAW8B,OAAX,CAAmBsB,KAAnB,GAA2B,YAAU;AACjC,QAAIC,OAAO,KAAKC,MAAL,EAAX;AACAD,SAAKE,EAAL,GAAU,KAAKN,GAAf,CAFiC,CAEd;AACnB,WAAOI,KAAKnC,QAAZ;AACA,WAAOmC,IAAP;AACH,CALD;;kBAQepD,mBAASuD,KAAT,CAAe,MAAf,EAAuBxD,UAAvB,C","file":"User.js","sourcesContent":["import mongoose from 'mongoose';\nimport bcrypt from 'bcrypt';\nimport bcrypt_p from 'bcrypt-promise';\nimport jwt from 'jsonwebtoken';\nimport {throwError, to} from './../services/util.service';\nimport validate from 'mongoose-validator';\nimport CONFIG from './../config/config';\n\n\nlet UserSchema = mongoose.Schema({\n    first: {type: String},\n    last: {type: String},\n    phone: {\n        type: String, lowercase: true, trim: true, index: true, unique: true, sparse: true,//sparse is because now we have two possible unique keys that are optional\n        validate: [validate({\n            validator: 'isNumeric',\n            arguments: [7, 20],\n            message: 'Not a valid phone number.',\n        })]\n    },\n    email: {\n        type: String, lowercase: true, trim: true, index: true, unique: true, sparse: true,\n        validate: [validate({\n            validator: 'isEmail',\n            message: 'Not a valid email.',\n        }),]\n    },\n    // select=false, do not select the password by default.\n    password: {type: String, select: false},\n\n}, {timestamps: true});\n\nUserSchema.pre('save', async function(next){\n\n    if(this.isModified('password') || this.isNew){\n\n        let err, salt, hash;\n        [err, salt] = await to(bcrypt.genSalt(10));\n        if(err) throwError(err.message, true);\n\n        [err, hash] = await to(bcrypt.hash(this.password, salt));\n        if(err) throwError(err.message, true);\n\n        this.password = hash;\n\n    } else{\n        return next();\n    }\n});\n\nUserSchema.methods.comparePassword = async function(pw) {\n    let err, pass\n    if (!this.password) throwError('password not set');\n\n    [err, pass] = await to(bcrypt_p.compare(pw, this.password));\n    if (err) throwError(err);\n\n    if (!pass) throwError('invalid password');\n\n    return this;\n};\n\n\nUserSchema.virtual('full_name').set(function (name) {\n    var split = name.split(' ');\n    this.first = split[0];\n    this.last = split[1];\n});\n\nUserSchema.virtual('full_name').get(function () { //now you can treat as if this was a property instead of a function\n    if(!this.first) return null;\n    if(!this.last) return this.first;\n\n    return this.first + ' ' + this.last;\n});\n\nUserSchema.methods.getJWT = function(){\n    let expiration_time = parseInt(CONFIG.jwt_expiration);\n    return \"Bearer \"+jwt.sign({user_id:this._id}, CONFIG.jwt_encryption, {expiresIn: expiration_time});\n};\nUserSchema.methods.toWeb = function(){\n    let json = this.toJSON();\n    json.id = this._id;//this is for the front end\n    delete json.password;\n    return json;\n};\n\n\nexport default mongoose.model('User', UserSchema);\n"]}